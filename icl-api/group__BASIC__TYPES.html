<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): Fundamental Data Type Definitions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Fundamental Data Type Definitions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab21f404160d56751f53c4b12618acb26"><td class="memItemLeft" align="right" valign="top">typedef Ipp64f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#gab21f404160d56751f53c4b12618acb26">icl::icl64f</a></td></tr>
<tr class="memdesc:gab21f404160d56751f53c4b12618acb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">64Bit floating point type for the ICL  <a href="group__BASIC__TYPES.html#gab21f404160d56751f53c4b12618acb26">More...</a><br /></td></tr>
<tr class="separator:gab21f404160d56751f53c4b12618acb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5e66277c0b9e4cee1d9e0f51768f49"><td class="memItemLeft" align="right" valign="top">typedef Ipp32f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga9d5e66277c0b9e4cee1d9e0f51768f49">icl::icl32f</a></td></tr>
<tr class="memdesc:ga9d5e66277c0b9e4cee1d9e0f51768f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">32Bit floating point type for the ICL  <a href="group__BASIC__TYPES.html#ga9d5e66277c0b9e4cee1d9e0f51768f49">More...</a><br /></td></tr>
<tr class="separator:ga9d5e66277c0b9e4cee1d9e0f51768f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42327266b9cc89a04bb7cf0ff1b1b0b2"><td class="memItemLeft" align="right" valign="top">typedef Ipp32s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga42327266b9cc89a04bb7cf0ff1b1b0b2">icl::icl32s</a></td></tr>
<tr class="memdesc:ga42327266b9cc89a04bb7cf0ff1b1b0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">32bit signed integer type for the ICL  <a href="group__BASIC__TYPES.html#ga42327266b9cc89a04bb7cf0ff1b1b0b2">More...</a><br /></td></tr>
<tr class="separator:ga42327266b9cc89a04bb7cf0ff1b1b0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79af5b84ad2c6e4acf44ae0530d89269"><td class="memItemLeft" align="right" valign="top">typedef Ipp16s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga79af5b84ad2c6e4acf44ae0530d89269">icl::icl16s</a></td></tr>
<tr class="memdesc:ga79af5b84ad2c6e4acf44ae0530d89269"><td class="mdescLeft">&#160;</td><td class="mdescRight">16bit signed integer type for the ICL (range [-32767, 32768 ])  <a href="group__BASIC__TYPES.html#ga79af5b84ad2c6e4acf44ae0530d89269">More...</a><br /></td></tr>
<tr class="separator:ga79af5b84ad2c6e4acf44ae0530d89269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03c5fb8fe5763e6a400b4651b0eec2d7"><td class="memItemLeft" align="right" valign="top">typedef Ipp8u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga03c5fb8fe5763e6a400b4651b0eec2d7">icl::icl8u</a></td></tr>
<tr class="memdesc:ga03c5fb8fe5763e6a400b4651b0eec2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">8Bit unsigned integer type for the ICL  <a href="group__BASIC__TYPES.html#ga03c5fb8fe5763e6a400b4651b0eec2d7">More...</a><br /></td></tr>
<tr class="separator:ga03c5fb8fe5763e6a400b4651b0eec2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f5627da7615ee9860e366e2e771f91"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga34f5627da7615ee9860e366e2e771f91">icl::icl32u</a></td></tr>
<tr class="memdesc:ga34f5627da7615ee9860e366e2e771f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">32bit unsigned integer type for the ICL  <a href="group__BASIC__TYPES.html#ga34f5627da7615ee9860e366e2e771f91">More...</a><br /></td></tr>
<tr class="separator:ga34f5627da7615ee9860e366e2e771f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b4318f62652caa4cc291e16636744d"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#gac6b4318f62652caa4cc291e16636744d">icl::icl16u</a></td></tr>
<tr class="memdesc:gac6b4318f62652caa4cc291e16636744d"><td class="mdescLeft">&#160;</td><td class="mdescRight">16bit unsigned integer type for the ICL  <a href="group__BASIC__TYPES.html#gac6b4318f62652caa4cc291e16636744d">More...</a><br /></td></tr>
<tr class="separator:gac6b4318f62652caa4cc291e16636744d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c122921c8e13cf99c202c2c22ed15b"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga39c122921c8e13cf99c202c2c22ed15b">icl::icl64s</a></td></tr>
<tr class="memdesc:ga39c122921c8e13cf99c202c2c22ed15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">64bit signed integer type for the ICL  <a href="group__BASIC__TYPES.html#ga39c122921c8e13cf99c202c2c22ed15b">More...</a><br /></td></tr>
<tr class="separator:ga39c122921c8e13cf99c202c2c22ed15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13baa33c3e879d955e140fc3fc0b8630"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga13baa33c3e879d955e140fc3fc0b8630">icl::icl64u</a></td></tr>
<tr class="memdesc:ga13baa33c3e879d955e140fc3fc0b8630"><td class="mdescLeft">&#160;</td><td class="mdescRight">64bit unsigned integer type for the ICL  <a href="group__BASIC__TYPES.html#ga13baa33c3e879d955e140fc3fc0b8630">More...</a><br /></td></tr>
<tr class="separator:ga13baa33c3e879d955e140fc3fc0b8630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd186227034339aa861c315583f7b0af"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; <a class="el" href="group__BASIC__TYPES.html#ga9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#gadd186227034339aa861c315583f7b0af">icl::icl32c</a></td></tr>
<tr class="memdesc:gadd186227034339aa861c315583f7b0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">float comples type  <a href="group__BASIC__TYPES.html#gadd186227034339aa861c315583f7b0af">More...</a><br /></td></tr>
<tr class="separator:gadd186227034339aa861c315583f7b0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593a364c2581b5ab88db9a875b3872be"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; <a class="el" href="group__BASIC__TYPES.html#gab21f404160d56751f53c4b12618acb26">icl64f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BASIC__TYPES.html#ga593a364c2581b5ab88db9a875b3872be">icl::icl64c</a></td></tr>
<tr class="memdesc:ga593a364c2581b5ab88db9a875b3872be"><td class="mdescLeft">&#160;</td><td class="mdescRight">float comples type  <a href="group__BASIC__TYPES.html#ga593a364c2581b5ab88db9a875b3872be">More...</a><br /></td></tr>
<tr class="separator:ga593a364c2581b5ab88db9a875b3872be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="OV"></a>
Overview</h1>
<pre class="fragment">The ICLUtils package contains C++ support functions and classes that do no depend on the
ICL's image classes.

The packe can be grouped into the following modules:
-# \ref TIME
-# \ref EXCEPT
-# \ref THREAD
-# \ref RANDOM
-# \ref UTILS
-# \ref PA
-# \ref XML
-# \ref STRUTILS
-# \ref FUNCTION
</pre><h1><a class="anchor" id="SUPPORT"></a>
Support classes</h1>
<pre class="fragment">The ICLUtils package provides some of ICL's most basic support classes and interfaces:
- &lt;tt&gt;icl::Rect&lt;/tt&gt; and &lt;tt&gt;icl::Rect32f&lt;/tt&gt;
- &lt;tt&gt;icl::Point&lt;/tt&gt; and &lt;tt&gt;icl::Point32f&lt;/tt&gt;
- &lt;tt&gt;icl::Size&lt;/tt&gt; and &lt;tt&gt;icl::Size32f&lt;/tt&gt;
- &lt;tt&gt;icl::Range&lt;/tt&gt; and &lt;tt&gt;icl::SteppingRange&lt;/tt&gt;
- &lt;tt&gt;icl::StraightLine2D&lt;/tt&gt;
- &lt;tt&gt;icl::SmartPtr&lt;/tt&gt;
- &lt;tt&gt;icl::Uncopyable&lt;/tt&gt;
- &lt;tt&gt;icl::ShallowCopyable&lt;/tt&gt;
</pre><h1><a class="anchor" id="STRING"></a>
String manipulation functions</h1>
<pre class="fragment">String manipulation is always a bit complicated in C++, even though C++'s
&lt;tt&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;-header provides the powerful &lt;tt&gt;std::string&lt;/tt&gt;-class.
The header file &lt;tt&gt;ICLUtils/StringUtils.h&lt;/tt&gt; provides some additional
utility functions and function-template that facilitate string manipulation
significantly:
- &lt;tt&gt;icl::str&lt;/tt&gt;: this function can be used to convert a given data-type into a
  string. Duo to it's &lt;tt&gt;std::ostringstream&lt;/tt&gt;-based implementation,
  &lt;tt&gt;icl::str&lt;/tt&gt; can be used for all classes and types, that provide the
  &lt;tt&gt;std::ostream-operator '&lt;&lt;' &lt;/tt&gt;
- &lt;tt&gt;parse&lt;/tt&gt;: this function uses an instance of &lt;tt&gt;std::istringstream&lt;/tt&gt;
  to implement parsing functionality for all classes and types that
  provide an implementation of the &lt;tt&gt;std::istream-operator '&gt;&gt;'&lt;/tt&gt;
- &lt;tt&gt;icl::cat&lt;/tt&gt; concatenates a range of strings
- &lt;tt&gt;icl::parseVecStr&lt;/tt&gt; parses a comma separated list of string element-wise
  into an &lt;tt&gt;std::vector&lt;/tt&gt; of given type
- &lt;tt&gt;icl::match&lt;/tt&gt; applies regular-expression matching (including the possibility
  of obtaining sub-matches
- &lt;tt&gt;icl::tok&lt;/tt&gt; provides an efficient interface for string-tokenization. It can
  be set up to use string-delimiters or a list of single character delimiters and
  an escape-character can be defined

@see STRUTILS
</pre><h1><a class="anchor" id="PA_"></a>
ProgArg evaluation environment</h1>
<pre class="fragment">The progam argument evaluation environment can ca used to handle arguments,
that are given to your programm in the command line. It consists essentially
of tree main functions:
- &lt;tt&gt;icl::painit&lt;/tt&gt; initializes the environment, by defining allowed and mandatory
  arguments and their sub-arguments as well as their default values. Furthermore
  painit parses the actually given list of program arguments and creates
  appropriate error messages if errors occur (e.g., if an unknown argument was
  found of if an argument got not enough sub-arguments).
- &lt;tt&gt;icl::paex&lt;/tt&gt; can optionally be used to explain certain arguments more
  detailed
- &lt;tt&gt;icl::pa&lt;/tt&gt; in the end is provided to detect whether a certain argument
  was given or to obtain it's sub-arguments

@see PA
</pre><h1><a class="anchor" id="FIXED_MATRIX"></a>
Fixed matrices</h1>
<pre class="fragment">ICL's icl::FixedMatrix-template class is a convenient and powerful tool for
high-level object-oriented fixed-size matrix calculations. It provides a large set
of basic functions and operators. The additional header
&lt;tt&gt;ICLUtils/FixedMatrixUtils.h&lt;/tt&gt; provides further high-level matrix-algebra-related
functions like:
- &lt;tt&gt;icl::svd_fixed&lt;/tt&gt; for &lt;em&gt;Singular value decomposition&lt;/em&gt;
   (using Intel IPP internally)
- &lt;tt&gt;icl::decompose_QR&lt;/tt&gt; and &lt;tt&gt;icl::decompose_RQ&lt;/tt&gt; for &lt;em&gt;QR/RQ-matrix
   decompsition&lt;/em&gt;
- &lt;tt&gt;icl::pinv&lt;/tt&gt; which computes the pseudo-inverse of a given matrix using a
  very stable QR-decompsition based approach.

The dimensions of a FixedMatrix instance is given using template parameters, which
allows us to use a fixed-size-array for its internal data storage, which significantly
increases processing speed. However, if the dimensions of a matrix cannot be determined
at compilation time ICL's dynamic matrix class must be used.
</pre><h1><a class="anchor" id="DYN_MATRIX"></a>
Dynamic Matrices</h1>
<pre class="fragment">ICL's icl::DynMatrix-template-class is similar to the fixed-size one, except, it uses
dynamic memory for it's data storage. Furthermore, DynMatrix instances can be created
as shallow wrappers around externally managed data. The extra-header
&lt;tt&gt;ICLUtils/DynMatrixUtils.h&lt;/tt&gt; contains a much larger set of optionally Intel IPP
and Intel MKL accelerated matrix functions.

@see LINALG
</pre><h1><a class="anchor" id="CONFIG_FILE"></a>
XML Configuration Files</h1>
<pre class="fragment">The &lt;tt&gt;icl::ConfigFile&lt;/tt&gt; class is a powerful tool for the creation of configurable
applications. Configuration files use the XML-format, which is natively parsed and
created using ICL's own XML-parser. We decided to provide an own parser, in order to
avoid an additional large dependency. The ConfigFile class provides convenient access
functions that allow to obtain or event to set entries of the hierarchically organized
xml-files. \n
Moreover, the ICLQt package provides a GUI-component that can easily be embedded into
complex GUIs in order to provide an interface manipulate configuration file entries
at run-time.

@see XML
</pre><h1><a class="anchor" id="TIMING_AND_THREADING"></a>
Timing and threading utilities</h1>
<pre class="fragment">Dynamic applications ofter make use of several threads. In particular, Qt-GUI-based
applications normally have a dedicated working thread in addition to the applications
main-thread which processes Qt's GUI-event-loop. To facilitate handling of threaded
applications, the ICLUtils package contains classes as &lt;tt&gt;icl::Thread&lt;/tt&gt; and
&lt;tt&gt;icl::Mutex&lt;/tt&gt; which provide an object-oriented interface for the underlying
posix-thread (using &lt;tt&gt;libptread&lt;/tt&gt;) layer. Timing and benchmarking tools as e.g.
&lt;tt&gt;icl::Time&lt;/tt&gt; or &lt;tt&gt;icl::StackTimer&lt;/tt&gt; complete this function-set.

@see THREAD
@see TIME
</pre><h1><a class="anchor" id="FUNCTION_SECTION"></a>
Function Class Creation</h1>
<h2><a class="anchor" id="FGI"></a>
General Information</h2>
<h2><a class="anchor" id="FUE"></a>
Usage Example</h2>
<p>The following example was taken from ICL/ICLUtils/examples/function-test.cpp. It demonstrates most used cases of ICL's Function class template. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Function_8h.html">ICLUtils/Function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// first, we need some global functions and class definitions</span></div><div class="line"><span class="comment">// whose methods can be wrapped later on.</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceicl_1_1utils.html">icl::utils</a>;</div><div class="line"><span class="keywordtype">void</span> global_foo(){</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;void global_foo()&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> global_foo2(){</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;int global_foo() returning 5&quot;</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 5;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> global_add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a+b; }</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Foo{</div><div class="line">  <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Foo.add(&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;) = &quot;</span> &lt;&lt; a+b &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> a+b;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> operator()(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Foo(&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;) = &quot;</span> &lt;&lt; a+b &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> a+b;</div><div class="line">  }</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> show_int(<span class="keywordtype">int</span> i){</div><div class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">  <span class="comment">// simple parameterless global function</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;void&gt;</a> gfoo(global_foo);</div><div class="line">  gfoo();</div><div class="line"></div><div class="line">  <span class="comment">// global function that returns an int</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;int&gt;</a> gfoo2(global_foo2);</div><div class="line">  std::cout &lt;&lt; gfoo2() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Implicit cast from function with return value to function without return value</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;void&gt;</a> gfoo3 = <span class="keyword">function</span>(global_foo2);</div><div class="line">  gfoo3();</div><div class="line"></div><div class="line">  <span class="comment">// Global function with parameters</span></div><div class="line">  <span class="comment">// identical to function(global_add)(4,5)</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;int,int,int&gt;</a> gadd(global_add);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;global_add(4,5)=&quot;</span> &lt;&lt; gadd(4,5) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Global function with parameters (ignoring the result of the function)</span></div><div class="line">  <span class="comment">// Functions with non-void return type can always be casted into another</span></div><div class="line">  <span class="comment">// Function type with return type (the return value is simply ignored then)</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;void,int,int&gt;</a> gadd_void = <span class="keyword">function</span>(global_add); gadd_void(4,5);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// create an std::vector</span></div><div class="line">  std::vector&lt;int&gt; v;</div><div class="line"></div><div class="line">  <span class="comment">// void-Member function with one parameter</span></div><div class="line">  <span class="comment">// preserve type-correctness (argument is not int, but const int&amp;)</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;void,const int&amp;&gt;</a> vpush = <span class="keyword">function</span>(v,&amp;std::vector&lt;int&gt;::push_back);</div><div class="line">  vpush(1);  vpush(2);  vpush(3);</div><div class="line"></div><div class="line">  <span class="comment">// access elements with this function</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;int&amp;,unsigned int&gt;</a> vat = <span class="keyword">function</span>(v,&amp;std::vector&lt;int&gt;::at);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;elem 0: &quot;</span> &lt;&lt; vat(0) &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;elem 1: &quot;</span> &lt;&lt; vat(1) &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;elem 2: &quot;</span> &lt;&lt; vat(2) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// create an instance of the foo class</span></div><div class="line">  Foo f;</div><div class="line"></div><div class="line">  <span class="comment">// creating a list of functions of same type</span></div><div class="line">  std::vector&lt;Function&lt;int,int,int&gt; &gt; list;</div><div class="line">  list.push_back(<span class="keyword">function</span>(f,&amp;Foo::add)); <span class="comment">// member function</span></div><div class="line">  list.push_back(<span class="keyword">function</span>(f,<a class="code" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor&lt;int,int,int&gt;</a>())); <span class="comment">// a functor</span></div><div class="line">  list.push_back(global_add);  <span class="comment">// a global function</span></div><div class="line"></div><div class="line">  <span class="comment">// Finally, we are also able to implement the FunctionImpl-interface</span></div><div class="line">  <span class="comment">// here, we have to implement the corresponding constructor</span></div><div class="line">  <span class="comment">// (which must const!!!)</span></div><div class="line">  <span class="keyword">struct </span>Impl : <a class="code" href="structicl_1_1utils_1_1FunctionImpl.html">FunctionImpl</a>&lt;int,int,int&gt;{</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> operator()(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)<span class="keyword"> const</span>{</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;custom impl:operator()(a,b) = &quot;</span> &lt;&lt; a+b &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> a+b;</div><div class="line">    }</div><div class="line">  };</div><div class="line">  <span class="comment">// list.push_back(function(new Impl));</span></div><div class="line">  <span class="comment">// would also be possible, but implicit cast is possible</span></div><div class="line">  list.push_back(<span class="keyword">new</span> Impl);</div><div class="line"></div><div class="line">  <span class="comment">// clear the vector of ints also by using a Function-instance:</span></div><div class="line">  <span class="keyword">function</span>(v,&amp;std::vector&lt;int&gt;::clear)();</div><div class="line"></div><div class="line">  <span class="comment">// create a function that wraps the index operator</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;int&amp;,unsigned int&gt;</a> vidxop = <span class="keyword">function</span>(v,&amp;std::vector&lt;int&gt;::operator[]);</div><div class="line"></div><div class="line">  <span class="comment">// push the results of the function in the vector</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;list.size();++i){</div><div class="line">    vpush(list[i](i,i));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// create a function for the vector size</span></div><div class="line">  <a class="code" href="structicl_1_1utils_1_1Function.html">Function&lt;size_t&gt;</a> vsize = <span class="keyword">function</span>(v,&amp;std::vector&lt;int&gt;::size);</div><div class="line"></div><div class="line">  <span class="comment">// show the result of the vector-size function</span></div><div class="line">  std::cout &lt;&lt; vsize() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;vsize();++i){</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;v[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; vidxop(i) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// or use a function and std::for_each to print the results</span></div><div class="line">  std::for_each(v.begin(),v.end(),<span class="keyword">function</span>(Foo::show_int));</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__FUNCTION.html">ICL's Function Class and Creation Functions</a> </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga79af5b84ad2c6e4acf44ae0530d89269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79af5b84ad2c6e4acf44ae0530d89269">&#9670;&nbsp;</a></span>icl16s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Ipp16s <a class="el" href="group__BASIC__TYPES.html#ga79af5b84ad2c6e4acf44ae0530d89269">icl::icl16s</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16bit signed integer type for the ICL (range [-32767, 32768 ]) </p>

</div>
</div>
<a id="gac6b4318f62652caa4cc291e16636744d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6b4318f62652caa4cc291e16636744d">&#9670;&nbsp;</a></span>icl16u</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="group__BASIC__TYPES.html#gac6b4318f62652caa4cc291e16636744d">icl::icl16u</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>16bit unsigned integer type for the ICL </p>

</div>
</div>
<a id="gadd186227034339aa861c315583f7b0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd186227034339aa861c315583f7b0af">&#9670;&nbsp;</a></span>icl32c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::complex&lt;<a class="el" href="group__BASIC__TYPES.html#ga9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&gt; <a class="el" href="group__BASIC__TYPES.html#gadd186227034339aa861c315583f7b0af">icl::icl32c</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>float comples type </p>

</div>
</div>
<a id="ga9d5e66277c0b9e4cee1d9e0f51768f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d5e66277c0b9e4cee1d9e0f51768f49">&#9670;&nbsp;</a></span>icl32f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Ipp32f <a class="el" href="group__BASIC__TYPES.html#ga9d5e66277c0b9e4cee1d9e0f51768f49">icl::icl32f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32Bit floating point type for the ICL </p>

</div>
</div>
<a id="ga42327266b9cc89a04bb7cf0ff1b1b0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42327266b9cc89a04bb7cf0ff1b1b0b2">&#9670;&nbsp;</a></span>icl32s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Ipp32s <a class="el" href="group__BASIC__TYPES.html#ga42327266b9cc89a04bb7cf0ff1b1b0b2">icl::icl32s</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32bit signed integer type for the ICL </p>

</div>
</div>
<a id="ga34f5627da7615ee9860e366e2e771f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f5627da7615ee9860e366e2e771f91">&#9670;&nbsp;</a></span>icl32u</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__BASIC__TYPES.html#ga34f5627da7615ee9860e366e2e771f91">icl::icl32u</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32bit unsigned integer type for the ICL </p>

</div>
</div>
<a id="ga593a364c2581b5ab88db9a875b3872be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga593a364c2581b5ab88db9a875b3872be">&#9670;&nbsp;</a></span>icl64c</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::complex&lt;<a class="el" href="group__BASIC__TYPES.html#gab21f404160d56751f53c4b12618acb26">icl64f</a>&gt; <a class="el" href="group__BASIC__TYPES.html#ga593a364c2581b5ab88db9a875b3872be">icl::icl64c</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>float comples type </p>

</div>
</div>
<a id="gab21f404160d56751f53c4b12618acb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab21f404160d56751f53c4b12618acb26">&#9670;&nbsp;</a></span>icl64f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Ipp64f <a class="el" href="group__BASIC__TYPES.html#gab21f404160d56751f53c4b12618acb26">icl::icl64f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64Bit floating point type for the ICL </p>

</div>
</div>
<a id="ga39c122921c8e13cf99c202c2c22ed15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c122921c8e13cf99c202c2c22ed15b">&#9670;&nbsp;</a></span>icl64s</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="group__BASIC__TYPES.html#ga39c122921c8e13cf99c202c2c22ed15b">icl::icl64s</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64bit signed integer type for the ICL </p>

</div>
</div>
<a id="ga13baa33c3e879d955e140fc3fc0b8630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13baa33c3e879d955e140fc3fc0b8630">&#9670;&nbsp;</a></span>icl64u</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group__BASIC__TYPES.html#ga13baa33c3e879d955e140fc3fc0b8630">icl::icl64u</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>64bit unsigned integer type for the ICL </p>

</div>
</div>
<a id="ga03c5fb8fe5763e6a400b4651b0eec2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03c5fb8fe5763e6a400b4651b0eec2d7">&#9670;&nbsp;</a></span>icl8u</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Ipp8u <a class="el" href="group__BASIC__TYPES.html#ga03c5fb8fe5763e6a400b4651b0eec2d7">icl::icl8u</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8Bit unsigned integer type for the ICL </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 16 2019 16:36:16 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
